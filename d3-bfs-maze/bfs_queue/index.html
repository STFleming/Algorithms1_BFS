<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

text {
  font-family: sans-serif;
  font-size: 10px;
}

</style>
<svg width="960" height="600"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>


// graph.json
var graph_json = "simple_graph.json";

var visited_colour = "#bfef45";
var unvisited_colour = "gainsboro";
var queued_colour = "#ffe119";
var active_colour = "#f58231";

var node_size = 25;
var force_strength = -360;
var link_width = 3;

var start_node_id = undefined;

// maze.json

// Use a force layout to plot the graph
// force directed layout has been adapted from https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

var graph_data = [];

var visited = [];
var bfs_queue = [];
var up_next = [];

// NOTE: NONE OF THIS IS OPTIMISED. THE CODE WAS WRITTEN QUICKLY TO DEMONSTRATE THE BFS ALGORITHM AS I DID NOT HAVE MUCH FREE TIME TO WORK ON IT FOR THE INTERVIEW PRESENTATION :)

// -=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//         Queue Visualiser and helpers
// -=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
var queue_x = 150;
var queue_y = 500;
var queue_item_w = 30;
var queue_item_h = 70;
var queue_item_spacing = 5;
var vis_queue = [];

// shuffle along all the items in the queue
function visShuffleAlong() {

	var x_pos = queue_x;
	//for(var i in vis_queue) {
	for (var i = vis_queue.length -1; i>=0; i--) {
		d3.select("#qBox_"+vis_queue[i])
		  .transition()
		  .attr("x", function(d) {
			  return x_pos + queue_item_w + queue_item_spacing;
		  })
		  .duration(250);

		d3.select("#qText_"+vis_queue[i])
		  .transition()
		  .attr("x", function(d) { 
			  return x_pos + queue_item_w + queue_item_spacing + queue_item_w/4;
		  })
		  .duration(250);

		x_pos = x_pos + queue_item_w + queue_item_spacing;
	}
}

// clear all elements in the vis queue
function visQClear(){
	for(var i in vis_queue) {
		d3.select("#qBox_"+vis_queue[i]).remove();
		d3.select("#qText_"+vis_queue[i]).remove();
	}
}


// performs the visualisation of an item being added to the queue
function visAddItem(node_id){

   visShuffleAlong();

   // New item appears after a delay to allow the shuffle to happen
   var delay = (vis_queue.length == 0) ? 0 : 250;
   setTimeout( function() {
       svg.append("rect")
          .attr("id", "qBox_"+node_id)
          .attr("x", queue_x)
          .attr("y", queue_y)
          .attr("height", queue_item_h)
          .attr("width", queue_item_w)
          .style("fill", "white")
          .style("stroke-width", 1)
          .style("stroke", "black")
          .style("opacity", 1.0);

       svg.append("text")
          .attr("id", "qText_"+node_id)
          .attr("x", queue_x + queue_item_w/4)
          .attr("y", queue_y + queue_item_h/2 + 4)
          .style("font-family", "serif")
	      .style("opacity", 1.0)
          .style("font-size", 18)
          .text(node_id);
   }, delay);

   vis_queue.push(node_id);
}

// performs the visualisation of an item being removed from the queue
function visRemoveItem() {
	d3.select("#qBox_"+ vis_queue[0]).transition().style("opacity", 0.1).duration(250);
	d3.select("#qText_"+vis_queue[0]).transition().style("opacity", 0.1).duration(250);
	setTimeout( function() {
		d3.select("#qBox_"+ vis_queue[0]).remove();
		d3.select("#qText_"+vis_queue[0]).remove();
		vis_queue.shift();
	}, 250);
}

function Queue() {
	this.elements = [];
};

// enque
Queue.prototype.enque = function (e) {
	this.elements.push(e);
	visAddItem(e);
};

// peek
Queue.prototype.peek = function () {
	return !this.isEmpty() ? this.elements[0] : undefined;
}

// deque
Queue.prototype.deque = function() {
	visRemoveItem();
	return this.elements.shift();
};

// isEmpty
Queue.prototype.isEmpty = function() {
	return this.elements.length == 0;
};

// length
Queue.prototype.length = function() {
	return this.elements.length;
}

let node_queue = new Queue();

// -=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// returns true if a node has already been visited
// doing a linear walk over a visited list every node consideration is ridiculous but I'm in a hurry
function hasVisited(node_id) {
	for(var v in visited){
		if(node_id == visited[v])
			return true;
	}
	return false;
}

// when provided with a node returns all the nodes connected to it
function neighbours(node_id) {
	n = []; // the list of neighbours of node_id
	for(var l in graph_data.links) {
		if(graph_data.links[l].source.id == node_id) {
			n.push(graph_data.links[l].target.id);
		}
		if(graph_data.links[l].target.id == node_id) {
			n.push(graph_data.links[l].source.id);
		}
	}
	return n;
}

var current_node = 0;
var fin = false;

// reset the BFS
function resetBFS() {
	for(var node in graph_data.nodes) {
		d3.select("#node_" + graph_data.nodes[node].id).style("fill", unvisited_colour).style("opacity", "1.0");  
	}
	visited = [];
	up_next = [];
	current_node = undefined;

	while(!node_queue.isEmpty()){
		node_queue.deque();
	}

	visQClear();
	fin = false;
    d3.selectAll("#node_highlight").remove(); 	
}

// highlights all unvisited neighbours
function highlightNextUp(node_id) {
	var possible = neighbours(node_id);
	for(var i in possible) {
		if(!hasVisited(possible[i])) {
			d3.select("#node_"+possible[i]).style("fill", queued_colour); 	
			up_next.push(possible[i]);
		}
	}
}


// change the colour of a given node 
function nodeColour(node_id, colour) {
    d3.select("#node_"+node_id).style("fill", colour); 	
}

// changes the colour, and opacity
function nodeVisitedVis(node_id) {
    d3.select("#node_"+node_id).style("opacity", "0.3").style("fill",visited_colour);
}

// highlight the current node
function nodeHighlight(node_id) {
  d3.selectAll("#node_highlight").remove(); 	

  var cx = d3.select("#node_"+node_id).attr("cx");
  var cy = d3.select("#node_"+node_id).attr("cy");

  d3.select(".nodes")
     .append("circle")
     .attr("id", "node_highlight")
     .attr("cx", cx)
     .attr("cy", cy)
     .attr("r", node_size + node_size*0.2)
     .style("stroke", "#800000")
     .style("fill", "none")
     .style("stroke-width", 2);

};

// clear the highlight
function nodeHighlightClear(){
  d3.selectAll("#node_highlight").remove(); 	
};

// step the BFS forward one position
function stepBFS() {
    console.log("step");
	if(up_next.length == 0) {
	    if(node_queue.isEmpty()) {
	        console.log("\t finished");
	        nodeVisitedVis(current_node);
	        nodeHighlightClear();
		    fin = true;
	    } else {
	        nodeVisitedVis(current_node);
	        current_node = node_queue.deque();	
	        console.log("\tDEQUE: Exploring new node " + current_node);
	        nodeColour(current_node, active_colour); 
	        nodeHighlight(current_node);

	        up_next = neighbours(current_node);
	        console.log("\tNeighbours: ");
	        console.log(up_next);
	    } 
	} else {
	    var nnode = up_next.shift();
        nodeHighlight(nnode);
	    if(!hasVisited(nnode)) {
            nodeColour(nnode, queued_colour);
	        console.log("\tENQUE: Adding Neighbour " + nnode); 
	    	node_queue.enque(nnode);
	        visited.push(nnode);
	    }
	}

}

// initialise the BFS
function initBFS() {
	d3.select("#node_"+start_node_id).style("fill", visited_colour);
    if(start_node_id != undefined) {
	    //node_queue.enque(start_node_id);
	    nodeVisitedVis(current_node);
	    current_node = start_node_id;
        nodeColour(current_node, active_colour);
        nodeHighlight(current_node);

        up_next = neighbours(current_node);
        visited.push(current_node);
    }
}

// Adds a button that when triggered executes func()
function addButton(x, y, text_in, func) {
   var button_width = 80;
   var button_height = 30;

  var button_text = svg.append("text")
      .attr("x", x + button_width/4 - text_in.length + 5)
      .attr("y", y + button_height/2 + 4)
      .style("font-family", "serif")
      .style("font-size", 18)
      .text(text_in);

   var button = svg.append("rect")
      .attr("x", x)
      .attr("y", y)
      .attr("height", button_height)
      .attr("width", button_width)
      .style("fill", "white")
      .style("stroke-width", 2)
      .style("stroke", "black")
      .style("opacity", 0.3)
      .on("mouseover", function() { d3.select(this).style("fill", queued_colour); d3.select(this).style("opacity", 0.3); })
      .on("mouseout",  function() { d3.select(this).style("fill", "white"); })
      .on("click", func);

}

// Adds a label to the diagram
function addLabel(x, y, text_in) {
	svg.append("text")
	   .attr("x", x)
	   .attr("y", y)
           .style("font-family", "serif")
           .style("font-size", 22)
           .style("text-decoration", "underline")
	   .text(text_in);
}

d3.json(graph_json, function(error, graph) {
  if (error) throw error;
  
  graph_data = graph;

  var simulation = d3.forceSimulation(graph.nodes)
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody().strength(force_strength))
    .force("center", d3.forceCenter(width / 2, height / 2))
		.stop();
  
  simulation.force("link")
      .links(graph.links);
  
  for (var i = 0; i < 300; ++i) simulation.tick();

  var link = svg.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(graph.links)
      .enter().append("line")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .attr("stroke-width", link_width);

  var node = svg.append("g")
      .attr("class", "nodes")
      .selectAll("circle")
      .data(graph.nodes)
      .enter().append("circle")
      .attr("id", function(d) { return "node_" + d.id; })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", node_size)
      .on("click", function(d) { resetBFS(); start_node_id = d.id; initBFS(); })
      .style("stroke", "black")
      .style("stroke-width", 2)
      .style("fill", unvisited_colour );

  var labels = svg.append("g")
      .attr("class", "labels")
      .selectAll("#node_label")
      .data(graph.nodes)
      .enter().append("text")
      .attr("id", "node_label")
      .attr("x", function(d) { return d.x - 10; })
      .attr("y", function(d) { return d.y - 5; })
      .text(function(d) {return d.id; } );

   initBFS();

   // control buttons
   addLabel(50,35,"Controls");
   addButton(150, 15, "step()", stepBFS); 
   addButton(250, 15, "reset()", resetBFS); 

});


</script>

